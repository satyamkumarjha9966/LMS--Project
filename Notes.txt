>>>>>>>>>>>> npm init

>>>>>>>>>>>> npm i bcryptjs cloudinary cookie-parser cors dotenv express jsonwebtoken mongoose multer nodemailer nodemon morgan --save

>>>>>>>>>>>> package.json
"type": "module"         = We have to always use type module formate that IMP to use ES6

>>>>>>>>>>>> server.js
import app from './app.js';
import { config } from 'dotenv';
config();

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
    console.log(`App is running at http:localhost:${PORT}`);
});

>>>>>>>>>>>>>> NOTES >>>> MIDDLEWARE
>>>>>>>>>>>> app.use(express.json());   = everthing will parse in json 
>>>>>>>>>>>> app.use(cors());           = To communicate cross origin platform
>>>>>>>>>>>> app.use(cookieParser());   = To ensure that any thing come from cookie will parse in json 
>>>>>>>>>>>> app.use(morgan('dev'))     = isse hum user dwara kiye gaye activity ko console me print kar pate hai

>>>>>>>>>>>> package.json
"dev": "nodemon server.js"
"main": "server.js"

>>>>>>>>>>>> app.js 
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';

const app = express();

// Middle Ware
app.use(express.json());
app.use(cors({
    origin: [process.env.FRONTEND_URL],
    credentials: true
}));
app.use(cookieParser());
// Middle Ware

app.use('/ping', (req, res) => {
    res.send('Pong')
});

// Routes of 3 Modules

app.all('*', (req, res) => {
    res.status(404).send('OOPS!! 404 Page Not Found');
});

export default app;

>>>>>>>>>>>> Making folder config, controllers, model, middleware, routes 

>>>>>>>>>>>> config > dbConnection.js || DB Connection 
import mongoose from "mongoose";

mongoose.set('strictQuery', false);    // Query is not in strict if small error come in querry ignore it not give error

const connectionToDB = async () => {
    try {
        const { connection } = await mongoose.connect(process.env.MONGO_URI);
    
        if (connection) {
            console.log(`Connected to MongoDB:${connection.host}`);
        }     
    } catch (error) {
        console.log(error);
        process.exit(1);        // Means end the complete process
    }
};

export default connectionToDB;

>>>>>>>>>>>> server.js 
app.listen(PORT, async () => {
    await connectionToDB();
    console.log(`App is running at http:localhost:${PORT}`);
});

>>>>>>>>>>>> routes > user.routes.js   || Making User Routes
import { Router } from "express";

const userRoutes = Router();

userRoutes.post('/signup', signup);
userRoutes.post('/signin', signin);
userRoutes.get('/logout', logout);
userRoutes.get('/me', getProfile);

export default userRoutes;

>>>>>>>>>>>> app.js  || Import user routes and use it 
import userRoutes from './routes/user.routes.js'; 
app.use('/api/v1/user', userRoutes)

>>>>>>>>>>>> controllers > user.controllers.js    || Making controller for user 
const signup = (req, res) => {

};

const signin = (req, res) => {

};

const logout = (req, res) => {

};

const getProfile = (req, res) => {

};

export {
    signup,
    signin,
    logout,
    getProfile
}

>>>>>>>>>>>> routes > user.routes.js    || Import user routes 
import { signup, signin, logout, getProfile } from '../controllers/user.contollers.js';

>>>>>>>>>>>> models > user.model.js    || Making User Model Schema 
import { Schema, model } from "mongoose";

const userSchema = new Schema({
    
});

const User = model('User', userSchema);

export default User;

>>>>>>>>>>>> models > user.model.js    || Defining User Schema in Detail
const userSchema = new Schema({
    fullName: {
        type: 'String',
        required: [true, 'Name is Required'],
        minLength: [5, 'Name must be at least 5 Characters'],
        maxLength: [50, 'Name should be less than 50 Characters'],
        lowercase: true,
        trim: true
    },
    email: {
        type: 'String',
        required: [true, 'Email is Required'],
        lowercase: true,
        trim: true,
        unique: true,
        // match: []
    },
    password: {
        type: 'String',
        required: [true, 'Password is Required'],
        minLength: [8, 'Password must be at least 8 Characters'],
        select: false,      // Means Default Query me Password mat dena When intencially query me dena bas
    },
    avatar: {
        public_id: {
            type: 'String'
        },
        secure_url: {
            type: 'String'
        }
    },
    role: {
        type: 'String',
        enum: ['USER', 'ADMIN'],          // How many types of role defining
        default: 'USER'
    },
    forgotPasswordToken: String,
    forgotPasswordExpiry: Date
}, {timestamps: true});

>>>>>>>>>>>> models > user.model.js    || Password Encryption
// Password Encryption
userSchema.pre('save', async function(next) {
    if (!this.isModified('password')) {
        return next();
    }

    this.password = await bcrypt.hash(this.password, 8)
});

>>>>>>>>>>>> controllers > user.controllers.js    || Defining User Controller in Detail with Functionality

    if (!fullName || !email || !password) {
        return next(new AppError('All Fields are Required', 400));    // ye abhi pura object return kar dega isliye hum middleware (by next) ka use karenge 
    }

>>>>>>>>>>>> utils > error.util.js || Making a Enrich Error Message
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);

        this.statusCode = statusCode;

        Error.captureStackTrace(this, this.constructor);  // Kis line me JS ka file phat gaya hai iske record ke liye
    }
}

export default AppError;

// Now you get a Enrich Error Message

>>>>>>>>>>>> middleware > error.middleware.js  
const errorMiddleware = (err, req, res, next) => {
    err.statusCode = err.statusCode || 500;
    err.message = err.message || "Something Went Wrong!";

    return res.status(err.statusCode).json({
        success: false,
        message: err.message,
        stack: err.stack
    })
};

export default errorMiddleware;

// Isse user ko message object me na jakar particular error show hoga 

>>>>>>>>>>>> app.js     || Importing Error Middle Ware 
app.use(errorMiddleware);

>>>>>>>>>>>> models > user.model.js    || Generating JWT Token
// Generating JWT Token
userSchema.methods = {
    generateJWTToken: async function () {
        return await jwt.sign(
            {id: this._id, email: this.email, subscription: this.subscription, role: this.role},
            process.env.JWT_SECRET,
            {
                expiresIn: process.env.JWT_EXPIRY 
            }
        )
    }
}

>>>>>>>>>>>> controllers > user.controllers.js    || cookieOptions = JWT Token 
const cookieOptions = {
    maxAge: 7*24*60*60*1000,     // 7 Days
    httpOnly: true,
    secure: true
}

>>>>>>>>>>>> controllers > user.controllers.js    || Defining User Controller of signup (with above ErrorMiddleware, util class, JWT token)
const signup = async (req, res, next) => {
    // Destructuring User Data
    const {fullName, email, password} = req.body;

    // Cross Check 1  || If any field is empty by User
    if (!fullName || !email || !password) {
        return next(new AppError('All Fields are Required', 400));    // ye abhi pura object return kar dega isliye hum middleware (by next) ka use karenge 
    }

    // Cross Check 2  || If Email Already Exist 
    const userExist = await User.findOne({ email });
    if (userExist) {
        return next(new AppError('Email Already Exist', 400));
    }

    // Collecting Data in Variable
    const user = await User.create({
        fullName,
        email,
        password,
        avatar: {
            public_id: email,
            secure_url: 'https://res.cloudinary.com/demo/image/upload/v1312461204/sample.jpg'
        }
    });

    // Cross Check 3  || If User Data Does not Save in DB
    if (!user) {
        return next(new AppError('User Registeration Failed, Pls Try Again', 500));
    };

    // TODO: File Upload

    // Saving User Data in DB
    await user.save();

    // To prevent sending password
    user.password = undefined;

    // Generating user Token (by generic method)
    const token = await user.generateJWTToken();

    // For Automatic Login || To save cookie in browser
    res.cookie('token', token, cookieOptions);

    // Sending Response to User on Successfull Registeration
    res.status(201).json({
        success: true,
        message: 'User Registered SuccessFully',
        user
    });
};

>>>>>>>>>>>> controllers > user.controllers.js    || Defining User Controller of signin
const signin = async (req, res) => {

    try {
        const { email, password } = req.body;
    
        // Cross Check 1  || If any field is empty by User
        if (!email || !password) {
            return next(new AppError('All Fields are Required', 400));    
        }
    
        // Finding user in DB
        const user = await User.findOne({
            email
        }).select('+password');               // Explicity Password Manga hai
    
        // Cross Check 2  || If email or password does not match
        if (!user || !user.comparePassword(password)) {
            return next(new AppError('Email or Password does not Match', 400));
        };
    
        // Generating JWT Token
        const token = await user.generateJWTToken();
        user.password = undefined;
    
        // Saving JET Token in Cookie
        res.cookie('token', token, cookieOptions);
    
        // Sending Success Message on User Successfully  Login
        res.status(200).json({
            success: true,
            message: 'User Loggedin Successfully',
            user
        });
    } catch (err) {
        return next(new AppError(err.message, 500));
    }
};

>>>>>>>>>>>> user.model.js || Making Logic for compare plain and Encrypted password using above signin contoller
userSchema.methods = {
    generateJWTToken: async function () {
        return await Jwt.sign(
            {id: this._id, email: this.email, subscription: this.subscription, role: this.role},
            process.env.JWT_SECRET,
            {
                expiresIn: process.env.JWT_EXPIRY 
            }
        )
    },

    // To compare plain and Encrypted Password
    comparePassword: async function (plainTextPassword) {
        return bcrypt.compare(plainTextPassword, this.password);
    }
}

>>>>>>>>>>>> controllers > user.controllers.js    || Defining User Controller of logout
const logout = (req, res) => {
    res.cookie('token', null, {
        secure: true,
        maxAge: 0,
        httpOnly: true
    });

    res.status(200).json({
        success: true,
        message: 'User Successfully Logged Out'
    });
};

>>>>>>>>>>>> controllers > user.controllers.js    || Defining User Controller of getProfile
const getProfile = async (req, res) => {
    try {
        // finding user id in auth.middleware.js  
        const userId = req.user.id;
        const user = await User.findById(userId);

        res.status(200).json({
            success: true,
            message: 'User Details',
            user
        });
    } catch (err) {
        return next(new AppError("Failed to Fetch User Details", 400));
    }
};

>>>>>>>>>>>> middleware > auth.middleware.js   ||   getting user data after authentication - use in getProfile controller
import AppError from "../utils/error.util.js";
import jwt from "jsonwebtoken";

const isLoggedIn = async (req, res, next) => {
    // fetching token from cookies
    const { token } = req.cookies;

    // Cross Check | is token available in cookies or not
    if (!token) {
        return next(new AppError('Unauthenticated, Pls Login Again', 401));
    }

    // Verifying token
    const userDetails = await jwt.verify(token, process.env.JWT_SECRET);

    // Storing Data
    req.user = userDetails;

    next();
}

export {
    isLoggedIn
}

>>>>>>>>>>>> user.routes.js  || update router for authorization
userRoutes.get('/me', isLoggedIn, getProfile);

>>>>>>>>>>>>  Image Uploaded Related Some Important Topic & Concepts 
when we send data in "Form Data" (Developer Tool > network > payload)
then it content-type = "multipart/form-data  (in header it set)
So that we can send img in "BINARY DATA" with form (rather than json but other data json me hi ajyega like name, email)
so ab hame 2 logic likhna hoga first server par data-type (of img) accept karne ke liye logic second img ka jo binary file ko convert kar sake real file (jpg) me aur uska use kar sake 